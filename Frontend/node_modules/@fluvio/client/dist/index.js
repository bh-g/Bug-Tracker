"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorCode = exports.SmartModuleType = exports.Offset = exports.OffsetFrom = exports.TopicSpec = exports.SpuGroupSpec = exports.SpuConfig = exports.CustomSpuSpec = exports.Encryption = exports.FluvioAdmin = exports.PartitionConsumer = exports.TopicProducer = exports.PartitionConsumerJS = exports.DEFAULT_OFFSET_FROM = exports.DEFAULT_OFFSET = exports.DEFAULT_MIN_ID = exports.DEFAULT_IGNORE_RACK_ASSIGNMENT = exports.DEFAULT_REPLICATION_FACTOR = exports.DEFAULT_PARTITIONS = exports.DEFAULT_TOPIC = exports.DEFAULT_ID = exports.DEFAULT_REPLICAS = exports.DEFAULT_PRIVATE_PORT = exports.DEFAULT_PUBLIC_PORT = exports.DEFAULT_PORT = exports.DEFAULT_HOST = void 0;
exports.stringToArrayBuffer = stringToArrayBuffer;
exports.arrayBufferToString = arrayBufferToString;
exports.DEFAULT_HOST = '127.0.0.1';
exports.DEFAULT_PORT = 9003;
exports.DEFAULT_PUBLIC_PORT = 9005;
exports.DEFAULT_PRIVATE_PORT = 9006;
exports.DEFAULT_REPLICAS = 3;
exports.DEFAULT_ID = 0;
exports.DEFAULT_TOPIC = 'message';
exports.DEFAULT_PARTITIONS = 1;
exports.DEFAULT_REPLICATION_FACTOR = 1;
exports.DEFAULT_IGNORE_RACK_ASSIGNMENT = false;
exports.DEFAULT_MIN_ID = 0;
exports.DEFAULT_OFFSET = 0;
exports.DEFAULT_OFFSET_FROM = 'end';
// Set the path to the native module
// to be used for the client; Set `FLUVIO_DEV`
// for development mode
function getDistPath() {
    switch (process.platform) {
        case 'darwin':
            return './darwin';
        case 'freebsd':
        case 'netbsd':
        case 'linux':
        case 'openbsd':
        case 'sunos':
            return './linux';
        case 'win32':
        case 'cygwin':
            return './win';
        default:
            console.log('Platform is not supported');
    }
}
const native_path = !process.env.FLUVIO_DEV
    ? `${getDistPath()}/index.node`
    : `${process.cwd()}/dist/${getDistPath()}/index.node`;
const native = require(`${native_path}`);
exports.PartitionConsumerJS = native.PartitionConsumerJS;
/**
 * # Topic Producer
 *
 * ## Overview
 *
 * An interface for producing events to a particular topic
 *
 * A TopicProducer allows you to send events to the specific topic it was initialized for.
 * Once you have a TopicProducer, you can send events to the topic,
 * choosing which partition each event should be delivered to.
 *
 * ## Example Construction
 *
 * Do not construct this manually, instead use the following method:
 *
 * ```TypeScript
 * const fluvio = new Fluvio({ host, port })
 *
 * await fluvio.connect();
 *
 * const producer = await fluvio.topicProducer("topic-name")
 * ```
 *
 * This class constructor is used internally by the Fluvio client
 * to provision a topic producer.
 *
 * The `inner` object is a private object that is the native module
 * created by the top-level Fluvio client.
 *
 * This class is not intended to be constructed manually.
 *
 */
class TopicProducer {
    /**
     * Private constructor
     *
     * This method is not intended to be used directly. This is a helper
     * method used by the `Fluvio` class to pass in a native object,
     * along with top-level Fluvio client options, if any.
     *
     * @param inner The native node module created by `await (new Fluvio().connect()).topicProducer()`
     */
    constructor(inner) {
        this.inner = inner;
    }
    /**
     * Factory method for creating a new topic Producer; This method is used by the
     * `Fluvio` class. It is not meant to be called directly;
     *
     * @param inner The native node module created by `await (new Fluvio().connect()).topicProducer()`
     */
    static create(inner) {
        return new TopicProducer(inner);
    }
    /**
     * Sends an event to a specific partition within this producer's topic
     * @param value Buffered data to send to the Fluvio partition
     * @param partition The partition that this record will be sent to
     */
    sendRecord(value, partition) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.inner.sendRecord(value, partition);
                return;
            }
            catch (error) {
                throw new Error(`failed to send record due to: ${error}`);
            }
        });
    }
    /**
     * Sends a key-value event to this producer's topic
     * @param key The Key data of the record to send
     * @param value The Value data of the record to send
     */
    send(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.inner.send(key, value);
        });
    }
    /**
     * Sends a list of key-value elements to this producer's topic
     * @param elements
     */
    sendAll(elements) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.inner.sendAll(elements);
        });
    }
    flush() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.inner.flush();
        });
    }
}
exports.TopicProducer = TopicProducer;
/**
 * # Partition Consumer
 *
 * ## Overview
 *
 * An interface for consuming events from a particular partition
 *
 * There are two ways to consume events: by "fetching" events and by "streaming" events.
 * Fetching involves specifying a range of events that you want to consume via their Offset.
 *
 * A fetch is a sort of one-time batch operation: you'll receive all of the events in your range all at once.
 *
 * When you consume events via Streaming, you specify a starting Offset and receive an object
 * that will continuously yield new events as they arrive.
 *
 * ## Example Construction
 *
 * Do not call this constructor manually, instead use the method below:
 *
 * ```TypeScript
 * const fluvio = new Fluvio({ host, port })
 *
 * const partition = 0;
 *
 * await fluvio.connect();
 * const consumer = await fluvio.partitionConsumer("topic-name", partition);
 * ```
 *
 * This class constructor is used internally by the Fluvio client
 * to provision a topic producer.
 *
 * The `inner` object is a private object that is the native module
 * created by the top-level Fluvio client.
 *
 * This class is not intended to be constructed manually.
 *
 */
class PartitionConsumer {
    /**
     * This method is not intended to be used directly. This is a helper
     * method used by the `Fluvio` class to pass in a native object,
     * along with top-level Fluvio client options, if any.
     *
     * @param inner The native node module created by `new Fluvio().connect().partitionConsumer()`
     * @param options Top-level Fluvio client options
     */
    constructor(inner) {
        this.inner = inner;
    }
    static create(inner) {
        return new PartitionConsumer(inner);
    }
    /**
     * Fetches events from a particular offset in the consumer's partition
     *
     * A "fetch" is one of the two ways to consume events in Fluvio.
     * It is a batch request for records from a particular offset in the partition.
     *
     * You specify the position of records to retrieve using an Offset,
     * and receive the events as a list of records.
     *
     * @param {Offset} offset Describes the location of an event stored in a Fluvio partition
     */
    fetch(offset) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!offset) {
                offset = new Offset();
            }
            return yield this.inner.fetch(offset);
        });
    }
    stream(offset, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.inner.stream(offset, cb);
            return;
        });
    }
    /**
     * This returns an [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator).
     * Usage:
     * ```typescript
     * const stream = await consumer.getIterator(Offset.FromBeginning())
     * for await (const next of stream) {
     *     console.log(next)
     * }
     * ```
     */
    createStream(offset) {
        return __awaiter(this, void 0, void 0, function* () {
            let stream = yield this.inner.createStream(offset);
            stream[Symbol.asyncIterator] = () => {
                return stream;
            };
            return stream;
        });
    }
    streamWithConfig(offset, config) {
        return __awaiter(this, void 0, void 0, function* () {
            let stream = yield this.inner.streamWithConfig(offset, config);
            stream[Symbol.asyncIterator] = () => {
                return stream;
            };
            return stream;
        });
    }
}
exports.PartitionConsumer = PartitionConsumer;
/**
 *  # Fluvio Admin Client
 *
 *  ## Overview
 *
 * An interface for managing a Fluvio cluster
 *
 * Most applications will not require administrator functionality. The FluvioAdmin interface is used to create,
 * edit, and manage Topics and other operational items. Think of the difference between regular clients of a Database
 * and its administrators. Regular clients may be applications which are reading and writing data to and from tables
 * that exist in the database. Database administrators would be the ones actually creating, editing, or deleting
 * tables. The same thing goes for Fluvio administrators.
 *
 * If you are writing an application whose purpose is to manage a Fluvio cluster for you,
 * you can gain access to the FluvioAdmin client via the regular Fluvio client
 *
 * ## Example Construction
 *
 * ```TypeScript
 * const fluvio = new Fluvio({ host, port })
 *
 * await fluvio.connect();
 *
 * const admin = await fluvio.admin();
 * ```
 *
 * ## Errors
 *
 * Creating an admin client will fail if you do not have admin authorization in the connected custer.
 *
 */
class FluvioAdmin {
    /**
     * This method is not intended to be used directly. This is a helper
     * method used by the `Fluvio` class to pass in a native object,
     * along with top-level Fluvio client options, if any.
     *
     * @param inner The native FluvioAdmin module, must be the value returned from `await new Fluvio().admin()`;
     * @param options Optional values inherited from top-level options;
     */
    constructor(inner, options) {
        this.inner = inner;
        this.options = options;
    }
    /**
     *
     * Create a new custom Streaming Processing Unit (SPU)
     *
     * @param {string} name Name of the custom spu;
     * @param {CustomSpuSpec} spec Pass in a custom spec or use a default based on
     * top-level options;
     */
    createCustomSpu(name, spec) {
        return __awaiter(this, void 0, void 0, function* () {
            const targetSpec = spec || new CustomSpuSpec(this.options);
            yield this.inner.createCustomSpu(name, targetSpec);
            return;
        });
    }
    /**
     *
     * Create a new managed Streaming Processing Unit (SPU)
     *
     * @param {string} name name of the managed spu group
     * @param {SpuGroupSpec} spec Optional specification for the SpuGroup. If no spec
     * is provided, default settings will be used.
     */
    createManagedSpu(name, spec) {
        return __awaiter(this, void 0, void 0, function* () {
            const targetSpec = spec || new SpuGroupSpec(this.options);
            yield this.inner.createManagedSpu(name, targetSpec);
            return;
        });
    }
    /**
     *
     * Create a new topic with an optional topic specification;
     *
     * @param {string} topic name of the topic
     * @param {TopicSpec} spec Topic specification
     */
    createTopic(topic, spec) {
        return __awaiter(this, void 0, void 0, function* () {
            const targetSpec = new TopicSpec(spec || this.options);
            return yield this.inner.createTopic(topic, targetSpec.opts);
        });
    }
    /**
     * Delete a custom SPU using either a string or number;
     *
     * @param {string | number} key SPU key to target for deletion;
     */
    deleteCustomSpu(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.inner.deleteCustomSpu(key);
        });
    }
    /**
     *
     * Delete a managed SPU by name
     *
     * @param {string} name Name of the managed SPU to delete;
     */
    deleteManagedSpu(name) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.inner.deleteManagedSpu(name);
        });
    }
    /**
     *
     * Delete a topic by name
     *
     * @param {string} topic Name of the topic to delete
     */
    deleteTopic(topic) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.inner.deleteTopic(topic);
        });
    }
    /**
     *
     * Find a topic by name
     *
     * @param {string} topic Name of the topic to find;
     *
     */
    findTopic(topic) {
        return __awaiter(this, void 0, void 0, function* () {
            const buffer = yield this.inner.findTopic(topic);
            return JSON.parse(arrayBufferToString(buffer));
        });
    }
    /**
     * List SPUs
     * TODO: convert stringified json to structured types;
     */
    listSpu() {
        return __awaiter(this, void 0, void 0, function* () {
            const buffer = yield this.inner.listSpu();
            return arrayBufferToString(buffer);
        });
    }
    /**
     * List topics
     */
    listTopic() {
        return __awaiter(this, void 0, void 0, function* () {
            const buffer = yield this.inner.listTopic();
            return arrayBufferToString(buffer);
        });
    }
    /**
     * List partitions
     */
    listPartitions() {
        return __awaiter(this, void 0, void 0, function* () {
            const buffer = yield this.inner.listPartitions();
            return arrayBufferToString(buffer);
        });
    }
    /**
     * Find a partition by topic name;
     * @param topic topic name to search partition by
     */
    findPartition(topic) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.inner.findPartition(topic);
        });
    }
}
exports.FluvioAdmin = FluvioAdmin;
/**
 *
 * # Fluvio TypeScript / NodeJS Client
 *
 * ## Overview
 *
 * The NodeJS client for communicating with Fluvio clusters.
 *
 * ## Example Construction
 *
 * ```TypeScript
 *
 * import Fluvio, { RecordSet } from '@fluvio/client';
 *
 * // define the name of the topic to use
 * const TOPIC_NAME = "my-topic"
 *
 * // define the partition where the topic
 * // records will be stored;
 * const PARTITION = 0
 *
 * // Instantiate a new fluvio client
 * const fluvio = new Fluvio({
 *  host: '127.0.0.1',
 *  port: 9003
 * });
 *
 * // Explicitly connect to the fluvio cluster;
 * await fluvio.connect();
 *
 * //// Fluvio Admin Client
 *
 * // Create a new Fluvio Admin Client to manage
 * // topics and partitions
 * const admin = await fluvio.admin();
 *
 * // Create a new topic
 * await admin.createTopic(TOPIC_NAME)
 *
 * //// Topic Producer
 *
 * // Create a topic producer for the topic;
 * const producer = await fluvio.topicProducer(TOPIC_NAME);
 *
 * // Send a new topic record
 * producer.sendRecord("stringified data", PARTITION)
 *
 * //// Partition Consumer
 *
 * // Instantiate a new topic listener;
 * const consumer = await fluvio.partitionConsumer(TOPIC_NAME, PARTITION)
 *
 * // Listen for new topics sent by a topic producer;
 * await consumer.listen(async (data: RecordSet) => {
 *   // handle data record
 * })
 * ```
 *
 * ## Uses Node Native Modules
 *
 * TypeScript wrapper around native fluvio core module written in Rust.
 *
 * Core module is generated from node-bindgen. This TypeScript
 * wrapper provides type definitions and generates the JavaScript
 * client.
 */
class Fluvio {
    /**
     *
     * @param { Options } options Options provides top-level access to common
     * configurable values used by the Fluvio client.
     */
    constructor(options) {
        // Use the native module as the core library;
        this.inner = native;
        this.options = options || {};
    }
    /**
     * Add static method to quickly create a connected client;
     * @param options Fluvio options passed into new fluvio instance;
     */
    static connect(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const fluvio = new Fluvio(options);
            yield fluvio.connect();
            return fluvio;
        });
    }
    /**
     *
     * @param options Optionally pass in connection host options (e.g. { host: '' })
     * uses the partial Options type; This does not override the default options,
     * only replaces default options in this case;
     */
    connect(options) {
        return __awaiter(this, void 0, void 0, function* () {
            // only set connection if client is undefined
            if (!this.client) {
                const host = (options === null || options === void 0 ? void 0 : options.host) ? options.host : this.options.host;
                const port = (options === null || options === void 0 ? void 0 : options.port) ? options.port : this.options.port;
                this.client =
                    host && port
                        ? yield this.inner.connect(`${host}:${port}`)
                        : yield this.inner.connect();
            }
            return this;
        });
    }
    /**
     * Check to ensure this.client has been set. This method is used internally to check
     * the connection status of the client before calling a method using the internal client.
     */
    checkConnection() {
        if (!this.client) {
            throw new Error('Failed to find socket; must call `.connect()` method to create a connection before calling this method;');
        }
    }
    /**
     * Creates a new TopicProducer for the given topic name
     *
     * Currently, producers are scoped to a specific Fluvio topic.
     * That means when you send events via a producer,
     * you must specify which partition each event should go to.
     *
     * @param {string} topic Name of the topic to create a producer for
     */
    topicProducer(topic) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            this.checkConnection();
            const inner = yield ((_a = this.client) === null || _a === void 0 ? void 0 : _a.topicProducer(topic));
            if (!inner) {
                throw new Error('Failed to create topic producer');
            }
            return TopicProducer.create(inner);
        });
    }
    /**
     *
     * Creates a new PartitionConsumer for the given topic and partition
     *
     * Currently, consumers are scoped to both a specific Fluvio topic and to a particular
     * partition within that topic. That means that if you have a topic with multiple partitions,
     * then in order to receive all of the events in all of the partitions,
     * you will need to create one consumer per partition.
     *
     * @param topic topic string
     * @param partition partition id
     */
    partitionConsumer(topic, partition) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            this.checkConnection();
            const inner = yield ((_a = this.client) === null || _a === void 0 ? void 0 : _a.partitionConsumer(topic, partition));
            if (!inner) {
                throw new Error('Failed to create partition consumer');
            }
            return PartitionConsumer.create(inner);
        });
    }
    /**
     * Provides an interface for managing a Fluvio cluster
     */
    admin() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            this.checkConnection();
            const inner = yield ((_a = this.client) === null || _a === void 0 ? void 0 : _a.admin());
            if (!inner) {
                throw new Error('Failed to create FluvioAdmin client');
            }
            return new FluvioAdmin(inner, this.options);
        });
    }
}
exports.default = Fluvio;
var Encryption;
(function (Encryption) {
    Encryption["Plaintext"] = "Plaintext";
    Encryption["Ssl"] = "Ssl";
})(Encryption || (exports.Encryption = Encryption = {}));
class CustomSpuSpec {
    constructor(options) {
        this.id = (options === null || options === void 0 ? void 0 : options.id) || getRandomId();
        this.privateEndpoint = {
            host: (options === null || options === void 0 ? void 0 : options.host) || exports.DEFAULT_HOST,
            port: exports.DEFAULT_PRIVATE_PORT,
            encryption: (options === null || options === void 0 ? void 0 : options.encryption) || Encryption.Plaintext,
        };
        this.publicEndpoint = {
            port: exports.DEFAULT_PUBLIC_PORT,
            ingress: (options === null || options === void 0 ? void 0 : options.ingress) || [
                {
                    hostname: exports.DEFAULT_HOST,
                },
            ],
            encryption: (options === null || options === void 0 ? void 0 : options.encryption) || Encryption.Plaintext,
        };
        if (options === null || options === void 0 ? void 0 : options.rack) {
            this.rack = options.rack;
        }
    }
}
exports.CustomSpuSpec = CustomSpuSpec;
class SpuConfig {
    constructor(options) {
        this.env = (options === null || options === void 0 ? void 0 : options.env) || [];
        if (options === null || options === void 0 ? void 0 : options.rack) {
            this.rack = options.rack;
        }
        if (options === null || options === void 0 ? void 0 : options.replication) {
            this.replication = options.replication;
        }
        if (options === null || options === void 0 ? void 0 : options.storage) {
            this.storage = options.storage;
        }
    }
}
exports.SpuConfig = SpuConfig;
class SpuGroupSpec {
    constructor(options) {
        this.minId = (options === null || options === void 0 ? void 0 : options.minId) || exports.DEFAULT_MIN_ID;
        this.replicas = (options === null || options === void 0 ? void 0 : options.replicas) || exports.DEFAULT_REPLICAS;
        this.spuConfig = new SpuConfig(options);
    }
}
exports.SpuGroupSpec = SpuGroupSpec;
class TopicSpec {
    constructor(options) {
        if (options.maps) {
            this.opts = {
                maps: options.maps,
            };
        }
        else {
            this.opts = {
                partitions: options.partitions || exports.DEFAULT_PARTITIONS,
                replicationFactor: options.replicationFactor || exports.DEFAULT_REPLICATION_FACTOR,
                ignoreRackAssignment: options.ignoreRackAssignment ||
                    exports.DEFAULT_IGNORE_RACK_ASSIGNMENT,
            };
        }
    }
}
exports.TopicSpec = TopicSpec;
var OffsetFrom;
(function (OffsetFrom) {
    OffsetFrom["Beginning"] = "beginning";
    OffsetFrom["End"] = "end";
})(OffsetFrom || (exports.OffsetFrom = OffsetFrom = {}));
class Offset {
    constructor(options) {
        this.index = (options === null || options === void 0 ? void 0 : options.index) || exports.DEFAULT_OFFSET;
        this.from = (options === null || options === void 0 ? void 0 : options.from) || exports.DEFAULT_OFFSET_FROM;
    }
    static FromBeginning() {
        return new Offset({ index: 0, from: OffsetFrom.Beginning });
    }
    static FromEnd() {
        return new Offset({ index: 0, from: OffsetFrom.End });
    }
}
exports.Offset = Offset;
var SmartModuleType;
(function (SmartModuleType) {
    SmartModuleType["Filter"] = "filter";
    SmartModuleType["Map"] = "map";
    SmartModuleType["ArrayMap"] = "array_map";
    SmartModuleType["FilterMap"] = "filter_map";
})(SmartModuleType || (exports.SmartModuleType = SmartModuleType = {}));
var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["UnknownServerError"] = 0] = "UnknownServerError";
    ErrorCode[ErrorCode["None"] = 1] = "None";
    ErrorCode[ErrorCode["OffsetOutOfRange"] = 2] = "OffsetOutOfRange";
    ErrorCode[ErrorCode["NotLeaderForPartition"] = 3] = "NotLeaderForPartition";
    ErrorCode[ErrorCode["StorageError"] = 4] = "StorageError";
    ErrorCode[ErrorCode["SpuError"] = 5] = "SpuError";
    ErrorCode[ErrorCode["SpuRegisterationFailed"] = 6] = "SpuRegisterationFailed";
    ErrorCode[ErrorCode["SpuOffline"] = 7] = "SpuOffline";
    ErrorCode[ErrorCode["SpuNotFound"] = 8] = "SpuNotFound";
    ErrorCode[ErrorCode["SpuAlreadyExists"] = 9] = "SpuAlreadyExists";
    ErrorCode[ErrorCode["TopicError"] = 10] = "TopicError";
    ErrorCode[ErrorCode["TopicNotFound"] = 11] = "TopicNotFound";
    ErrorCode[ErrorCode["TopicAlreadyExists"] = 12] = "TopicAlreadyExists";
    ErrorCode[ErrorCode["TopicPendingInitialization"] = 13] = "TopicPendingInitialization";
    ErrorCode[ErrorCode["TopicInvalidConfiguration"] = 14] = "TopicInvalidConfiguration";
    ErrorCode[ErrorCode["PartitionPendingInitialization"] = 15] = "PartitionPendingInitialization";
    ErrorCode[ErrorCode["PartitionNotLeader"] = 16] = "PartitionNotLeader";
})(ErrorCode || (exports.ErrorCode = ErrorCode = {}));
// utility methods
function getRandomId() {
    // NOTE: Determine a better id than timestamp + random;
    return +(Math.random() * 1e4).toFixed(0) + 1;
}
function stringToArrayBuffer(data) {
    const buf = new ArrayBuffer(data.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0; i < data.length; i++) {
        bufView[i] = data.charCodeAt(i);
    }
    return buf;
}
function arrayBufferToString(data) {
    return Buffer.from(data).toString('utf8');
}
//# sourceMappingURL=index.js.map