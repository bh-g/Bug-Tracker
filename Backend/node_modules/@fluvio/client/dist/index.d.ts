export declare const DEFAULT_HOST = "127.0.0.1";
export declare const DEFAULT_PORT = 9003;
export declare const DEFAULT_PUBLIC_PORT = 9005;
export declare const DEFAULT_PRIVATE_PORT = 9006;
export declare const DEFAULT_REPLICAS = 3;
export declare const DEFAULT_ID = 0;
export declare const DEFAULT_TOPIC = "message";
export declare const DEFAULT_PARTITIONS = 1;
export declare const DEFAULT_REPLICATION_FACTOR = 1;
export declare const DEFAULT_IGNORE_RACK_ASSIGNMENT = false;
export declare const DEFAULT_MIN_ID = 0;
export declare const DEFAULT_OFFSET = 0;
export declare const DEFAULT_OFFSET_FROM = "end";
export declare const PartitionConsumerJS: any;
/**
 * Top-level Fluvio Client options;
 *
 * These options are unstable and may be categorized into
 * more specific interfaces; For now, this is the global options
 * used by the entirety of the fluvio client;
 *
 * It is best practice to use explicit arguments directly with the class methods
 * If an option or argument does not exist that is optional, a default value will be
 * used.
 */
export interface Options {
    host?: string;
    port?: number;
    ingress?: IngressAddr[];
    rack?: string;
    encryption?: Encryption;
    minId?: number;
    replicas?: number;
    env?: EnvVar[];
    replication?: ReplicationConfig;
    storage?: StorageConfig;
    partitions?: number;
    replicationFactor?: number;
    ignoreRackAssignment?: boolean;
    maps?: PartitionMap[];
    topic?: string;
    partition?: number;
    id?: number;
    offsetIndex?: number;
    offsetFrom?: string;
}
/**
 * Provides access to the data within a Record that was consumed
 */
export interface Record {
    /**
     * Returns the Key of this Record as a byte buffer, or null if there is no key
     */
    key(): ArrayBuffer | null;
    /**
     * Returns true if this Record has a key, or false otherwise
     */
    hasKey(): boolean;
    /**
     * Returns the Value of this Record as a byte buffer
     */
    value(): ArrayBuffer;
    /**
     * Returns the Key of this Record as a string, or null if there is no key
     */
    keyString(): string | null;
    /**
     * Returns the Value of this Record as a string
     */
    valueString(): string;
}
/**
 * An item that may be sent via the Producer is a string or byte buffer.
 */
type ProducerItem = string | ArrayBuffer;
/**
 * A key/value element that may be sent via the Producer.
 */
export type KeyValue = [ProducerItem, ProducerItem];
export interface TopicProducer {
    sendRecord(data: string, partition: number): Promise<void>;
    send(key: ProducerItem, value: ProducerItem): Promise<void>;
    sendAll(records: KeyValue[]): Promise<void>;
    flush(): Promise<void>;
}
/**
 * # Topic Producer
 *
 * ## Overview
 *
 * An interface for producing events to a particular topic
 *
 * A TopicProducer allows you to send events to the specific topic it was initialized for.
 * Once you have a TopicProducer, you can send events to the topic,
 * choosing which partition each event should be delivered to.
 *
 * ## Example Construction
 *
 * Do not construct this manually, instead use the following method:
 *
 * ```TypeScript
 * const fluvio = new Fluvio({ host, port })
 *
 * await fluvio.connect();
 *
 * const producer = await fluvio.topicProducer("topic-name")
 * ```
 *
 * This class constructor is used internally by the Fluvio client
 * to provision a topic producer.
 *
 * The `inner` object is a private object that is the native module
 * created by the top-level Fluvio client.
 *
 * This class is not intended to be constructed manually.
 *
 */
export declare class TopicProducer {
    private inner;
    /**
     * Private constructor
     *
     * This method is not intended to be used directly. This is a helper
     * method used by the `Fluvio` class to pass in a native object,
     * along with top-level Fluvio client options, if any.
     *
     * @param inner The native node module created by `await (new Fluvio().connect()).topicProducer()`
     */
    private constructor();
    /**
     * Factory method for creating a new topic Producer; This method is used by the
     * `Fluvio` class. It is not meant to be called directly;
     *
     * @param inner The native node module created by `await (new Fluvio().connect()).topicProducer()`
     */
    static create(inner: TopicProducer): TopicProducer;
}
export interface PartitionConsumer {
    fetch(offset?: Offset): Promise<FetchablePartitionResponse>;
    stream(offset: Offset, cb: (record: Record) => void): Promise<void>;
    endStream(): Promise<void>;
    createStream(offset: Offset): Promise<AsyncIterable<Record>>;
    streamWithConfig(offset: Offset, config: ConsumerConfig): Promise<AsyncIterable<Record>>;
}
/**
 * # Partition Consumer
 *
 * ## Overview
 *
 * An interface for consuming events from a particular partition
 *
 * There are two ways to consume events: by "fetching" events and by "streaming" events.
 * Fetching involves specifying a range of events that you want to consume via their Offset.
 *
 * A fetch is a sort of one-time batch operation: you'll receive all of the events in your range all at once.
 *
 * When you consume events via Streaming, you specify a starting Offset and receive an object
 * that will continuously yield new events as they arrive.
 *
 * ## Example Construction
 *
 * Do not call this constructor manually, instead use the method below:
 *
 * ```TypeScript
 * const fluvio = new Fluvio({ host, port })
 *
 * const partition = 0;
 *
 * await fluvio.connect();
 * const consumer = await fluvio.partitionConsumer("topic-name", partition);
 * ```
 *
 * This class constructor is used internally by the Fluvio client
 * to provision a topic producer.
 *
 * The `inner` object is a private object that is the native module
 * created by the top-level Fluvio client.
 *
 * This class is not intended to be constructed manually.
 *
 */
export declare class PartitionConsumer {
    private inner;
    /**
     * This method is not intended to be used directly. This is a helper
     * method used by the `Fluvio` class to pass in a native object,
     * along with top-level Fluvio client options, if any.
     *
     * @param inner The native node module created by `new Fluvio().connect().partitionConsumer()`
     * @param options Top-level Fluvio client options
     */
    private constructor();
    static create(inner: PartitionConsumer): PartitionConsumer;
}
export interface FluvioAdmin {
    createCustomSpu(name: string, spec?: CustomSpuSpec): Promise<void>;
    createManagedSpu(name: string, spec?: SpuGroupSpec): Promise<void>;
    createTopic(topic: string, spec?: PartitionMaps | TopicReplicaParam): Promise<string>;
    deleteCustomSpu(key: string | number): Promise<void>;
    deleteManagedSpu(name: string): Promise<void>;
    deleteTopic(topic: string): Promise<string>;
    findTopic(topic: string): Promise<Topic>;
    listSpu(): Promise<string>;
    listTopic(): Promise<string>;
    listPartitions(): Promise<string>;
    findPartition(topic: string): Promise<PartitionSpecMetadata>;
}
/**
 *  # Fluvio Admin Client
 *
 *  ## Overview
 *
 * An interface for managing a Fluvio cluster
 *
 * Most applications will not require administrator functionality. The FluvioAdmin interface is used to create,
 * edit, and manage Topics and other operational items. Think of the difference between regular clients of a Database
 * and its administrators. Regular clients may be applications which are reading and writing data to and from tables
 * that exist in the database. Database administrators would be the ones actually creating, editing, or deleting
 * tables. The same thing goes for Fluvio administrators.
 *
 * If you are writing an application whose purpose is to manage a Fluvio cluster for you,
 * you can gain access to the FluvioAdmin client via the regular Fluvio client
 *
 * ## Example Construction
 *
 * ```TypeScript
 * const fluvio = new Fluvio({ host, port })
 *
 * await fluvio.connect();
 *
 * const admin = await fluvio.admin();
 * ```
 *
 * ## Errors
 *
 * Creating an admin client will fail if you do not have admin authorization in the connected custer.
 *
 */
export declare class FluvioAdmin {
    private inner;
    options?: Partial<Options>;
    /**
     * This method is not intended to be used directly. This is a helper
     * method used by the `Fluvio` class to pass in a native object,
     * along with top-level Fluvio client options, if any.
     *
     * @param inner The native FluvioAdmin module, must be the value returned from `await new Fluvio().admin()`;
     * @param options Optional values inherited from top-level options;
     */
    constructor(inner: FluvioAdmin, options?: Partial<Options>);
}
export interface FluvioClient {
    connect(options?: Partial<Options>): Promise<FluvioClient>;
    topicProducer(topic: string): Promise<TopicProducer>;
    partitionConsumer(topic: string, partition: number): Promise<PartitionConsumer>;
    admin(): Promise<FluvioAdmin>;
}
/**
 *
 * # Fluvio TypeScript / NodeJS Client
 *
 * ## Overview
 *
 * The NodeJS client for communicating with Fluvio clusters.
 *
 * ## Example Construction
 *
 * ```TypeScript
 *
 * import Fluvio, { RecordSet } from '@fluvio/client';
 *
 * // define the name of the topic to use
 * const TOPIC_NAME = "my-topic"
 *
 * // define the partition where the topic
 * // records will be stored;
 * const PARTITION = 0
 *
 * // Instantiate a new fluvio client
 * const fluvio = new Fluvio({
 *  host: '127.0.0.1',
 *  port: 9003
 * });
 *
 * // Explicitly connect to the fluvio cluster;
 * await fluvio.connect();
 *
 * //// Fluvio Admin Client
 *
 * // Create a new Fluvio Admin Client to manage
 * // topics and partitions
 * const admin = await fluvio.admin();
 *
 * // Create a new topic
 * await admin.createTopic(TOPIC_NAME)
 *
 * //// Topic Producer
 *
 * // Create a topic producer for the topic;
 * const producer = await fluvio.topicProducer(TOPIC_NAME);
 *
 * // Send a new topic record
 * producer.sendRecord("stringified data", PARTITION)
 *
 * //// Partition Consumer
 *
 * // Instantiate a new topic listener;
 * const consumer = await fluvio.partitionConsumer(TOPIC_NAME, PARTITION)
 *
 * // Listen for new topics sent by a topic producer;
 * await consumer.listen(async (data: RecordSet) => {
 *   // handle data record
 * })
 * ```
 *
 * ## Uses Node Native Modules
 *
 * TypeScript wrapper around native fluvio core module written in Rust.
 *
 * Core module is generated from node-bindgen. This TypeScript
 * wrapper provides type definitions and generates the JavaScript
 * client.
 */
export default class Fluvio implements FluvioClient {
    private inner;
    private options;
    private client?;
    /**
     *
     * @param { Options } options Options provides top-level access to common
     * configurable values used by the Fluvio client.
     */
    constructor(options?: Options);
    /**
     * Add static method to quickly create a connected client;
     * @param options Fluvio options passed into new fluvio instance;
     */
    static connect(options?: Options): Promise<Fluvio>;
    /**
     *
     * @param options Optionally pass in connection host options (e.g. { host: '' })
     * uses the partial Options type; This does not override the default options,
     * only replaces default options in this case;
     */
    connect(options?: Partial<Options>): Promise<FluvioClient>;
    /**
     * Check to ensure this.client has been set. This method is used internally to check
     * the connection status of the client before calling a method using the internal client.
     */
    private checkConnection;
    /**
     * Creates a new TopicProducer for the given topic name
     *
     * Currently, producers are scoped to a specific Fluvio topic.
     * That means when you send events via a producer,
     * you must specify which partition each event should go to.
     *
     * @param {string} topic Name of the topic to create a producer for
     */
    topicProducer(topic: string): Promise<TopicProducer>;
    /**
     *
     * Creates a new PartitionConsumer for the given topic and partition
     *
     * Currently, consumers are scoped to both a specific Fluvio topic and to a particular
     * partition within that topic. That means that if you have a topic with multiple partitions,
     * then in order to receive all of the events in all of the partitions,
     * you will need to create one consumer per partition.
     *
     * @param topic topic string
     * @param partition partition id
     */
    partitionConsumer(topic: string, partition: number): Promise<PartitionConsumer>;
    /**
     * Provides an interface for managing a Fluvio cluster
     */
    admin(): Promise<FluvioAdmin>;
}
export declare enum Encryption {
    Plaintext = "Plaintext",
    Ssl = "Ssl"
}
export interface Endpoint {
    port: number;
    host: string;
    encryption: string;
}
export interface IngressAddr {
    hostname?: string;
    ip?: string;
}
export interface IngressPort {
    port: number;
    ingress: IngressAddr[];
    encryption: string;
}
export interface CustomSpuSpec {
    id: number;
    publicEndpoint: IngressPort;
    privateEndpoint: Endpoint;
    rack?: string;
}
export declare class CustomSpuSpec {
    constructor(options?: Partial<Options>);
}
export interface EnvVar {
    name: string;
    value: string;
}
export interface StorageConfig {
    logDir?: string;
    size?: string;
}
export interface ReplicationConfig {
    inSyncReplicaMin?: number;
}
export interface SpuConfig {
    env: EnvVar[];
    storage?: StorageConfig;
    replication?: ReplicationConfig;
    rack?: string;
}
export declare class SpuConfig {
    constructor(options?: SpuConfig | Partial<Options>);
}
export interface ReplicaStatus {
    spu: number;
    hw: number;
    leo: number;
}
export interface PartitionSpecMetadata {
    name: string;
    spec: PartitionSpec;
    status: PartitionSpecStatus;
}
export interface PartitionSpecStatus {
    resolution: string;
    leader: ReplicaStatus;
    lsr: string;
    replicas: ReplicaStatus[];
}
export interface PartitionSpec {
    leader: number;
    replicas: number[];
}
export interface SpuGroupSpec {
    replicas: number;
    minId: number;
    spuConfig: SpuConfig;
}
export declare class SpuGroupSpec {
    constructor(options?: SpuGroupSpec | Partial<Options>);
}
export interface PartitionMap {
    id: number;
    replicas: number[];
}
export interface PartitionMaps {
    maps: PartitionMap[];
}
export interface TopicReplicaParam {
    partitions: number;
    replicationFactor: number;
    ignoreRackAssignment: boolean;
}
export interface TopicSpec {
    opts: PartitionMaps | TopicReplicaParam;
}
export declare class TopicSpec {
    constructor(options?: Partial<Options> | PartitionMaps | TopicReplicaParam | any);
}
export declare enum OffsetFrom {
    Beginning = "beginning",
    End = "end"
}
export interface Offset {
    index: number;
    from?: OffsetFrom | string;
}
export declare class Offset {
    constructor(options?: Offset);
    static FromBeginning(): Offset;
    static FromEnd(): Offset;
}
export declare enum SmartModuleType {
    Filter = "filter",
    Map = "map",
    ArrayMap = "array_map",
    FilterMap = "filter_map"
}
export interface ConsumerConfig {
    maxBytes?: number;
    smartmoduleType: SmartModuleType;
    /**
     * Path to a SmartModule WASM file.
     *
     * @remarks
     * Internally replaces the value provided to `smartmoduleData`,
     * you must provide one, either `smartmoduleFile` or `smartmoduleData`.
     */
    smartmoduleFile?: string;
    /**
     * Gzipped and Base64 encoded SmartModule WASM file.
     */
    smartmoduleData?: string;
    smartmoduleName?: string;
}
export interface BatchHeader {
    partitionLeaderEpoch: number;
    magic: number;
    crc: number;
    attributes: number;
    lastOffsetDelta: number;
    firstTimestamp: number;
    maxTimeStamp: number;
    producerId: number;
    producerEpoch: number;
    firstSequence: number;
}
export interface DefaultRecord {
    key: string;
    value: string;
    headers: number;
}
export interface Batch {
    baseOffset: number;
    batchLength: number;
    header: BatchHeader;
    records: DefaultRecord[];
}
export interface RecordSet {
    batches: Batch[];
}
export declare enum ErrorCode {
    UnknownServerError = 0,
    None = 1,
    OffsetOutOfRange = 2,
    NotLeaderForPartition = 3,
    StorageError = 4,
    SpuError = 5,
    SpuRegisterationFailed = 6,
    SpuOffline = 7,
    SpuNotFound = 8,
    SpuAlreadyExists = 9,
    TopicError = 10,
    TopicNotFound = 11,
    TopicAlreadyExists = 12,
    TopicPendingInitialization = 13,
    TopicInvalidConfiguration = 14,
    PartitionPendingInitialization = 15,
    PartitionNotLeader = 16
}
export interface FetchablePartitionResponse {
    partitionIndex: number;
    errorCode: ErrorCode;
    highWatermark: number;
    lastStableOffset: number;
    logStartOffset: number;
    records: RecordSet;
    /**
     * ```typescript
     * let response = await this.fluvioConsumer.fetch(Offset.FromStart())
     * response.toRecords().forEach(msg => {
     *    console.log(msg)
     * })
     * ```
     */
    toRecords(): Array<string>;
    aborted?: ArrayBuffer;
}
export declare function stringToArrayBuffer(data: string): ArrayBuffer;
export declare function arrayBufferToString(data: ArrayBuffer): string;
export interface Topic {
    name: string;
    spec: {
        type: string;
        partitions: number;
        replicationFactor: number;
        ignoreRackAssignment: boolean;
    };
    status: {
        resolution: string;
        replicaMap: {
            [key: string]: string;
        };
        reason: string;
    };
}
export {};
//# sourceMappingURL=index.d.ts.map